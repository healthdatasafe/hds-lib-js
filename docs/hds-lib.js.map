{"version":3,"file":"hds-lib.js","mappings":"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","sources":["webpack://HDSLib/./src/HDSModel.js","webpack://HDSLib/./src/utils.js","webpack://HDSLib/./src/HDSModel-ItemsDefs.js","webpack://HDSLib/./src/HDSModel-Authorizations.js","webpack://HDSLib/./src/HDSItemDef.js","webpack://HDSLib/./src/HDSModel-Streams.js","webpack://HDSLib/webpack/bootstrap","webpack://HDSLib/webpack/runtime/define property getters","webpack://HDSLib/webpack/runtime/hasOwnProperty shorthand","webpack://HDSLib/webpack/runtime/make namespace object","webpack://HDSLib/./src/index-webpack.js"],"sourcesContent":["const { deepFreeze } = require('./utils');\n\nconst LAZILY_LOADED = {\n  streams: require('./HDSModel-Streams'),\n  authorizations: require('./HDSModel-Authorizations'),\n  itemsDefs: require('./HDSModel-ItemsDefs')\n};\n\n/**\n * @class {HDSModel}\n * @property {object} modelData - Raw ModelData\n * @property {HDSModelItemsDefs} itemsDefs\n * @property {HDSModelStreams} streams\n * @property {HDSModelAuthorizations} authorizations\n */\nclass HDSModel {\n  /**\n   * JSON definition file URL.\n   * Should come from service/info assets.hds-model\n   * @type {string}\n   */\n  #modelUrl;\n\n  /** @type {object} RAW content of model definitions */\n  #modelData;\n\n  /**\n   * @private\n   * Map of properties loaded \"on demand\"\n   */\n  laziliyLoadedMap;\n\n  /**\n   * @param {string} modelUrl - JSON definition file URL. Should come from service/info assets.hds-model\n   */\n  constructor (modelUrl) {\n    this.#modelUrl = modelUrl;\n    this.laziliyLoadedMap = { };\n  }\n\n  /**\n   * Load model definitions\n   */\n  async load () {\n    const response = await fetch(this.#modelUrl);\n    const resultText = await response.text();\n    const result = JSON.parse(resultText);\n    this.#modelData = result;\n    // add key to items before freezing;\n    for (const [key, item] of Object.entries(this.#modelData.items)) {\n      item.key = key;\n    }\n    // make sure it cannot be modified\n    deepFreeze(this.#modelData);\n  }\n\n  /** RAW model data */\n  get modelData () {\n    if (!this.#modelData) throw new Error('Model not loaded call `await model.load()` first.');\n    return this.#modelData;\n  }\n}\n\n// add properties to be lazily loaded\nfor (const [prop, Obj] of Object.entries(LAZILY_LOADED)) {\n  Object.defineProperty(HDSModel.prototype, prop, {\n    get: function () {\n      if (!this.laziliyLoadedMap[prop]) this.laziliyLoadedMap[prop] = new Obj(this);\n      return this.laziliyLoadedMap[prop];\n    }\n  });\n}\n\nmodule.exports = HDSModel;\n","/**\n * Set of Misc utilities\n */\n\nmodule.exports = {\n  deepFreeze\n};\n\n/**\n * Recursively make immutable an object\n * @param {*} object\n * @returns {*}\n */\nfunction deepFreeze (object) {\n  // Retrieve the property names defined on object\n  const propNames = Reflect.ownKeys(object);\n\n  // Freeze properties before freezing self\n  for (const name of propNames) {\n    const value = object[name];\n\n    if ((value && typeof value === 'object') || typeof value === 'function') {\n      deepFreeze(value);\n    }\n  }\n\n  return Object.freeze(object);\n}\n","const HDSItemDef = require('./HDSItemDef');\n\n/**\n * ItemsDefs - Extension of HDSModel\n */\nclass HDSModelItemsDefs {\n  /**\n   * @type {HDSModel}\n   */\n  #model;\n\n  /**\n   * ItemDefs Cache\n   * KeyValue of itemsDefs\n   */\n  #itemsDefs;\n\n  /**\n   * get itemsData by streamId and eventType\n   */\n  #modelDataByStreamIdEventTypes;\n\n  constructor (model) {\n    this.#model = model;\n    this.#itemsDefs = {};\n    this.#modelDataByStreamIdEventTypes = {};\n    loadModelDataByStreamIdEventTypes(this.#model.modelData.items, this.#modelDataByStreamIdEventTypes);\n  }\n\n  /**\n   * get item for a key\n   * @param {string} key\n   * @param {boolean} [throwErrorIfNotFound] default `true`\n   */\n  forKey (key, throwErrorIfNotFound = true) {\n    if (this.#itemsDefs[key]) return this.#itemsDefs[key];\n    const defData = this.#model.modelData.items[key];\n    if (!defData) {\n      if (throwErrorIfNotFound) throw new Error('Cannot find item definition with key: ' + key);\n      return null;\n    }\n    this.#itemsDefs[key] = new HDSItemDef(key, defData);\n    return this.#itemsDefs[key];\n  }\n\n  /**\n   * get a definition for an event\n   * @param {Event} event\n   * @param {boolean} [throwErrorIfNotFound] default `true`\n   */\n  forEvent (event, throwErrorIfNotFound = true) {\n    const candidates = [];\n    for (const streamId of event.streamIds) {\n      const keyStreamIdEventType = streamId + ':' + event.type;\n      const candidate = this.#modelDataByStreamIdEventTypes[keyStreamIdEventType];\n      if (candidate) candidates.push(candidate);\n    }\n    if (candidates.length === 0) {\n      if (throwErrorIfNotFound) throw new Error('Cannot find definition for event: ' + JSON.stringify(event));\n      return null;\n    }\n    if (candidates.length > 1) {\n      throw new Error(`Found multiple matching definitions \"${candidates.map(c => (c.key)).join(', ')}\" for event: ${JSON.stringify(event)}`);\n    }\n    return this.forKey(candidates[0].key, throwErrorIfNotFound);\n  }\n}\n\nmodule.exports = HDSModelItemsDefs;\n\n/**\n * @private\n * Add key to model items and\n * load modeldata item into modelDataByStreamIdEventTypes for fast search\n */\nfunction loadModelDataByStreamIdEventTypes (model, map) {\n  for (const item of Object.values(model)) {\n    const eventTypes = [];\n    if (item.eventType) {\n      eventTypes.push(item.eventType);\n    } else {\n      eventTypes.push(...Object.keys(item.variations.eventType));\n    }\n    for (const eventType of eventTypes) {\n      const keyStreamIdEventType = item.streamId + ':' + eventType;\n      if (map[keyStreamIdEventType]) {\n        // should be tested with a faulty model\n        throw new Error(`Duplicate streamId + eventType \"${keyStreamIdEventType}\" for item ${JSON.stringify(item)}`);\n      }\n      map[keyStreamIdEventType] = item;\n    }\n  }\n}\n","/**\n * Authorizations - Extension of HDSModel\n */\nclass HDSModelAuthorizations {\n  /**\n   * @type {HDSModel}\n   */\n  #model;\n\n  constructor (model) {\n    this.#model = model;\n  }\n\n  /**\n   * Get minimal Authorization set for itemKeys\n   * /!\\ Does not handle requests with streamId = \"*\"\n   * @param {Array<itemKeys>} itemKeys\n   * @param {Object} [options]\n   * @param {string} [options.defaultLevel] (default = write) one of 'read', 'write', 'contribute', 'writeOnly'\n   * @param {boolean} [options.includeDefaultName] (default = true) defaultNames are needed for permission requests but not for access creation\n   * @param {Array<AuthorizationRequestItem>} [options.preRequest]\n   * @return {Array<AuthorizationRequestItem>}\n   */\n  forItemKeys (itemKeys, options = {}) {\n    const opts = {\n      defaultLevel: 'read',\n      preRequest: [],\n      includeDefaultName: true\n    };\n    Object.assign(opts, options);\n    const streamsRequested = {};\n    for (const pre of opts.preRequest) {\n      if (!pre.streamId) throw new Error(`Missing streamId in options.preRequest item: ${JSON.stringify(pre)}`);\n      // complete pre with defaultName if missing\n      if (opts.includeDefaultName && !pre.defaultName) {\n        // try to get it from streams Data\n        const stream = this.#model.streams.getDataById(pre.streamId, false);\n        if (stream) {\n          pre.defaultName = stream.name;\n        } else {\n          throw new Error(`No \"defaultName\" in options.preRequest item: ${JSON.stringify(pre)} and cannot find matching streams in default list`);\n        }\n      }\n      // check there is no defaultName if not required\n      if (!opts.includeDefaultName) {\n        if (pre.defaultName) throw new Error(`Do not include defaultName when not included explicitely on ${JSON.stringify(pre)}`);\n      }\n      // add default level\n      if (!pre.level) {\n        pre.level = opts.defaultLevel;\n      }\n      streamsRequested[pre.streamId] = pre;\n    }\n    // add streamId not already in\n    for (const itemKey of itemKeys) {\n      const itemDef = this.#model.itemsDefs.forKey(itemKey);\n      const streamId = itemDef.data.streamId;\n      if (!streamsRequested[streamId]) { // new streamId\n        const auth = { streamId, level: opts.defaultLevel };\n        if (opts.includeDefaultName) {\n          const stream = this.#model.streams.getDataById(streamId);\n          auth.defaultName = stream.name;\n        }\n        streamsRequested[streamId] = auth;\n      } else { // existing just adapt level\n        streamsRequested[streamId].level = mixAuthorizationLevels(streamsRequested[streamId].level, opts.defaultLevel);\n      }\n    }\n    // remove all permissions with a parent having identical or higher level\n    for (const auth of Object.values(streamsRequested)) {\n      const parents = this.#model.streams.getParentsIds(auth.streamId, false);\n      for (const parent of parents) {\n        const found = streamsRequested[parent];\n        if (found && authorizationOverride(found.level, auth.level)) {\n          // delete entry\n          delete streamsRequested[auth.streamId];\n          // break loop\n          continue;\n        }\n      }\n    }\n    return Object.values(streamsRequested);\n  }\n}\n\n/**\n * @typedef {Object} AuthorizationRequestItem\n * @property {string} streamId\n * @property {string} level\n * @property {string} defaultName\n */\n\n/**\n * Authorization level1 (parent) does override level2\n * Return \"true\" if identical or level1 == \"manage\"\n */\nfunction authorizationOverride (level1, level2) {\n  if (level1 === level2) return true;\n  if (level1 === 'manage') return true;\n  if (level1 === 'contribute' && level2 !== 'manage') return true;\n  return false;\n}\n\n/**\n * Given two authorization level, give the resulting one\n * @param {string} level1\n * @param {string} level1\n * @returns {string} level\n */\nfunction mixAuthorizationLevels (level1, level2) {\n  if (level1 === level2) return level1;\n  // sort level in orders [ 'contribute', 'manage', 'read', 'writeOnly' ]\n  const levels = [level1, level2].sort();\n  if (levels.includes('manage')) return 'manage'; // any & manage\n  if (levels[0] === 'contribute') return 'contribute'; // read ore writeOnly & contribute\n  if (levels[1] === 'writeOnly') return 'contribute'; // mix read & writeOnly\n  /* c8 ignore next */ // error if there .. 'read' & 'read' should have already be found\n  throw new Error(`Invalid level found level1: ${level1}, level2 ${level2}`);\n}\n\nmodule.exports = HDSModelAuthorizations;\n","class HDSItemDef {\n  #data;\n  #key;\n\n  constructor (key, definitionData) {\n    this.#key = key;\n    this.#data = definitionData;\n  }\n\n  get eventTypes () {\n    if (this.#data.eventType) return [this.#data.eventType];\n    return Object.keys(this.#data.variations.eventType);\n  }\n\n  get key () {\n    return this.#key;\n  }\n\n  get data () {\n    return this.#data;\n  }\n}\n\nmodule.exports = HDSItemDef;\n","/**\n * Streams - Extension of HDSModel\n */\nclass HDSModelStreams {\n  /**\n   * @type {HDSModel}\n   */\n  #model;\n\n  /**\n   * streamsById\n   * Map to find streams by Id\n   */\n  #modelStreamsById;\n\n  constructor (model) {\n    this.#model = model;\n    this.#modelStreamsById = {};\n    loadModelStreamsById(this.#model.modelData.streams, this.#modelStreamsById);\n  }\n\n  /**\n   * Get a list of streams to be created for usage of these keys (whithout children)\n   * @param {Array<string>} itemKeys\n   */\n  getNecessaryListForItemKeys (itemKeys) {\n    const result = [];\n    const streams = new Map(); // tempMap to keep streams already in\n    for (const itemKey of itemKeys) {\n      const itemDef = this.#model.itemsDefs.forKey(itemKey);\n      const streamParentIds = this.getParentsIds(itemDef.data.streamId, true, [itemDef.data.streamId]);\n      for (const streamId of streamParentIds) {\n        if (streams.has(streamId)) continue;\n        const stream = this.getDataById(streamId);\n        streams.set(streamId, true); // just to flag\n        result.push({\n          id: streamId,\n          name: stream.name, // to be translated\n          parentId: stream.parentId\n        });\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get stream Data by Id;\n   * @param {string} streamId\n   */\n  getDataById (streamId, throwErrorIfNotFound = true) {\n    const streamData = this.#modelStreamsById[streamId];\n    if (throwErrorIfNotFound && !streamData) throw new Error(`Stream with id: \"${streamId}\" not found`);\n    return streamData;\n  }\n\n  /**\n   * Get all parents id;\n   * @param {string} streamId\n   * @param {boolean} [throwErrorIfNotFound] default `true`\n   * @param {Array} [initialArray] - a pre-filled array\n   */\n  getParentsIds (streamId, throwErrorIfNotFound = true, initialArray = []) {\n    const streamData = this.getDataById(streamId, throwErrorIfNotFound);\n    if (!streamData) return initialArray;\n    if (streamData.parentId !== null) {\n      initialArray.unshift(streamData.parentId);\n      this.getParentsIds(streamData.parentId, true, initialArray);\n    }\n    return initialArray;\n  }\n}\n\nmodule.exports = HDSModelStreams;\n\n/**\n * @param {Array<stream>} streams\n * @param {Object<string, stream>} map - key value map\n */\nfunction loadModelStreamsById (streams, map) {\n  if (!streams) return;\n  for (const stream of streams) {\n    if (map[stream.id]) {\n      // should be tested with a faulty model\n      throw new Error(`Duplicate streamId \"${stream.id}\" for strean ${JSON.stringify(stream)}`);\n    }\n    map[stream.id] = stream;\n    loadModelStreamsById(stream.children, map);\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Export for webpack build\n */\nexport const HDSModel = require('./HDSModel');\n"],"names":["deepFreeze","LAZILY_LOADED","streams","authorizations","itemsDefs","HDSModel","laziliyLoadedMap","constructor","modelUrl","this","load","response","fetch","resultText","text","result","JSON","parse","key","item","Object","entries","items","modelData","Error","prop","Obj","defineProperty","prototype","get","module","exports","object","propNames","Reflect","ownKeys","name","value","freeze","HDSItemDef","model","map","values","eventTypes","eventType","push","keys","variations","keyStreamIdEventType","streamId","stringify","loadModelDataByStreamIdEventTypes","forKey","throwErrorIfNotFound","defData","forEvent","event","candidates","streamIds","type","candidate","length","c","join","mixAuthorizationLevels","level1","level2","levels","sort","includes","forItemKeys","itemKeys","options","opts","defaultLevel","preRequest","includeDefaultName","assign","streamsRequested","pre","defaultName","stream","getDataById","level","itemKey","data","auth","parents","getParentsIds","parent","found","definitionData","loadModelStreamsById","id","children","getNecessaryListForItemKeys","Map","itemDef","streamParentIds","has","set","parentId","streamData","initialArray","unshift","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","o","enumerable","obj","hasOwnProperty","call","r","Symbol","toStringTag"],"sourceRoot":""}