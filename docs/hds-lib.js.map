{"version":3,"file":"hds-lib.js","mappings":"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","sources":["webpack://HDSLib/./src/HDSModel.js","webpack://HDSLib/./src/HDSItemDef.js","webpack://HDSLib/webpack/bootstrap","webpack://HDSLib/webpack/runtime/define property getters","webpack://HDSLib/webpack/runtime/hasOwnProperty shorthand","webpack://HDSLib/webpack/runtime/make namespace object","webpack://HDSLib/./src/index-webpack.js"],"sourcesContent":["const HDSItemDef = require('./HDSItemDef');\n\nclass HDSModel {\n  /**\n   * JSON definition file\n   * Should come from service/info assets.hds-model\n   * @type {string}\n   */\n  #modelUrl;\n\n  /**\n   * Content on model definitions\n   * @type {object}\n   */\n  #modelData;\n\n  /**\n   * ItemDefs Cache\n   * KeyValue of itemsDefs\n   */\n  #itemsDefs;\n\n  /**\n   * get itemsDefs by streamId and eventType\n   */\n  #modelDataByStreamIdEventTypes;\n\n  /**\n   * streamsById\n   * Map to find streams by Id\n   */\n  #modelStreamsById;\n\n  /**\n   * JSON definition file\n   * Should come from service/info assets.hds-model\n   * @type {string}\n   */\n  constructor (modelUrl) {\n    this.#modelUrl = modelUrl;\n    this.#itemsDefs = {};\n    this.#modelDataByStreamIdEventTypes = {};\n    this.#modelStreamsById = {};\n  }\n\n  /**\n   * Load model definitions\n   */\n  async load () {\n    const response = await fetch(this.#modelUrl);\n    const resultText = await response.text();\n    const result = JSON.parse(resultText);\n    this.#modelData = result;\n    loadModelDataByStreamIdEventTypes(this.#modelData.items, this.#modelDataByStreamIdEventTypes);\n    loadModelStreamsById(this.#modelData.streams, this.#modelStreamsById);\n    deepFreeze(this.#modelData); // make sure it cannot be modified\n  }\n\n  /**\n   * get item for a key\n   * @param {string} key\n   * @param {boolean} [throwErrorIfNotFound] default `true`\n   */\n  itemDefForKey (key, throwErrorIfNotFound = true) {\n    if (this.#itemsDefs[key]) return this.#itemsDefs[key];\n    const defData = this.#modelData.items[key];\n    if (!defData) {\n      if (throwErrorIfNotFound) throw new Error('Cannot find item definition with key: ' + key);\n      return null;\n    }\n    this.#itemsDefs[key] = new HDSItemDef(key, defData);\n    return this.#itemsDefs[key];\n  }\n\n  /**\n   * get a definition for an event\n   * @param {Event} event\n   * @param {boolean} [throwErrorIfNotFound] default `true`\n   */\n  itemDefForEvent (event, throwErrorIfNotFound = true) {\n    const candidates = [];\n    for (const streamId of event.streamIds) {\n      const keyStreamIdEventType = streamId + ':' + event.type;\n      const candidate = this.#modelDataByStreamIdEventTypes[keyStreamIdEventType];\n      if (candidate) candidates.push(candidate);\n    }\n    if (candidates.length === 0) {\n      if (throwErrorIfNotFound) throw new Error('Cannot find definition for event: ' + JSON.stringify(event));\n      return null;\n    }\n    if (candidates.length > 1) {\n      throw new Error(`Found multiple matching definitions \"${candidates.map(c => (c.key)).join(', ')}\" for event: ${JSON.stringify(event)}`);\n    }\n    return this.itemDefForKey(candidates[0].key, throwErrorIfNotFound);\n  }\n\n  /**\n   * Get a list of streams to be created for usage of these keys (whithout children)\n   * @param {Array<string>} itemKeys\n   */\n  streamsGetNecessaryListForItemKeys (itemKeys) {\n    const result = [];\n    const streams = new Map(); // tempMap to keep streams already in\n    for (const itemKey of itemKeys) {\n      const itemDef = this.itemDefForKey(itemKey);\n      const streamParentIds = this.streamGetParentsIds(itemDef.data.streamId, true, [itemDef.data.streamId]);\n      for (const streamId of streamParentIds) {\n        if (streams.has(streamId)) continue;\n        const stream = this.streamDataGetById(streamId);\n        streams.set(streamId, true); // just to flag\n        result.push({\n          id: streamId,\n          name: stream.name, // to be translated\n          parentId: stream.parentId\n        });\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get stream Data by Id;\n   * @param {string} streamId\n   */\n  streamDataGetById (streamId, throwErrorIfNotFound = true) {\n    const streamData = this.#modelStreamsById[streamId];\n    if (throwErrorIfNotFound && !streamData) throw new Error(`Stream with id: \"${streamId}\" not found`);\n    return streamData;\n  }\n\n  /**\n   * Get all parents id;\n   * @param {string} streamId\n   * @param {boolean} [throwErrorIfNotFound] default `true`\n   * @param {Array} [initialArray] - a pre-filled array\n   */\n  streamGetParentsIds (streamId, throwErrorIfNotFound = true, initialArray = []) {\n    const streamData = this.streamDataGetById(streamId, throwErrorIfNotFound);\n    if (!streamData) return initialArray;\n    if (streamData.parentId !== null) {\n      initialArray.unshift(streamData.parentId);\n      this.streamGetParentsIds(streamData.parentId, true, initialArray);\n    }\n    return initialArray;\n  }\n\n  // --------- authorizations builder ------ //\n\n  /**\n   * @typedef {Object} AuthorizationRequestItem\n   * @property {string} streamId\n   * @property {string} level\n   * @property {string} defaultName\n   */\n\n  /**\n   * Get minimal Authorization set for itemKeys\n   * /!\\ Does not handle requests with streamId = \"*\"\n   * @param {Array<itemKeys>} itemKeys\n   * @param {Object} [options]\n   * @param {string} [options.defaultLevel] (default = write) one of 'read', 'write', 'contribute', 'writeOnly'\n   * @param {boolean} [options.includeDefaultName] (default = true) defaultNames are needed for permission requests but not for access creation\n   * @param {Array<AuthorizationRequestItem>} [options.preRequest]\n   * @return {Array<AuthorizationRequestItem>}\n   */\n  authorizationForItemKeys (itemKeys, options = {}) {\n    const opts = {\n      defaultLevel: 'read',\n      preRequest: [],\n      includeDefaultName: true\n    };\n    Object.assign(opts, options);\n    const streamsRequested = {};\n    for (const pre of opts.preRequest) {\n      if (!pre.streamId) throw new Error(`Missing streamId in options.preRequest item: ${JSON.stringify(pre)}`);\n      // complete pre with defaultName if missing\n      if (opts.includeDefaultName && !pre.defaultName) {\n        // try to get it from streams Data\n        const stream = this.streamDataGetById(pre.streamId, false);\n        if (stream) {\n          pre.defaultName = stream.name;\n        } else {\n          throw new Error(`No \"defaultName\" in options.preRequest item: ${JSON.stringify(pre)} and cannot find matching streams in default list`);\n        }\n      }\n      // check there is no defaultName if not required\n      if (!opts.includeDefaultName) {\n        if (pre.defaultName) throw new Error(`Do not include defaultName when not included explicitely on ${JSON.stringify(pre)}`);\n      }\n      // add default level\n      if (!pre.level) {\n        pre.level = opts.defaultLevel;\n      }\n      streamsRequested[pre.streamId] = pre;\n    }\n    // add streamId not already in\n    for (const itemKey of itemKeys) {\n      const itemDef = this.itemDefForKey(itemKey);\n      const streamId = itemDef.data.streamId;\n      if (!streamsRequested[streamId]) { // new streamId\n        const auth = { streamId, level: opts.defaultLevel };\n        if (opts.includeDefaultName) {\n          const stream = this.streamDataGetById(streamId);\n          auth.defaultName = stream.name;\n        }\n        streamsRequested[streamId] = auth;\n      } else { // existing just adapt level\n        streamsRequested[streamId].level = mixAuthorizationLevels(streamsRequested[streamId].level, opts.defaultLevel);\n      }\n    }\n    // remove all permissions with a parent having identical or higher level\n    for (const auth of Object.values(streamsRequested)) {\n      const parents = this.streamGetParentsIds(auth.streamId, false);\n      for (const parent of parents) {\n        const found = streamsRequested[parent];\n        if (found && authorizationOverride(found.level, auth.level)) {\n          // delete entry\n          delete streamsRequested[auth.streamId];\n          // break loop\n          continue;\n        }\n      }\n    }\n    return Object.values(streamsRequested);\n  }\n}\n\nmodule.exports = HDSModel;\n\n/**\n * Authorization level1 (parent) does override level2\n * Return \"true\" if identical or level1 == \"manage\"\n */\nfunction authorizationOverride (level1, level2) {\n  if (level1 === level2) return true;\n  if (level1 === 'manage') return true;\n  if (level1 === 'contribute' && level2 !== 'manage') return true;\n  return false;\n}\n\n/**\n * Given two authorization level, give the resulting one\n * @param {string} level1\n * @param {string} level1\n * @returns {string} level\n */\nfunction mixAuthorizationLevels (level1, level2) {\n  if (level1 === level2) return level1;\n  // sort level in orders [ 'contribute', 'manage', 'read', 'writeOnly' ]\n  const levels = [level1, level2].sort();\n  if (levels.includes('manage')) return 'manage'; // any & manage\n  if (levels[0] === 'contribute') return 'contribute'; // read ore writeOnly & contribute\n  if (levels[1] === 'writeOnly') return 'contribute'; // mix read & writeOnly\n  /* c8 ignore next */ // error if there .. 'read' & 'read' should have already be found\n  throw new Error(`Invalid level found level1: ${level1}, level2 ${level2}`);\n}\n\n/**\n * Recursively make immutable an object\n * @param {*} object\n * @returns {*}\n */\nfunction deepFreeze (object) {\n  // Retrieve the property names defined on object\n  const propNames = Reflect.ownKeys(object);\n\n  // Freeze properties before freezing self\n  for (const name of propNames) {\n    const value = object[name];\n\n    if ((value && typeof value === 'object') || typeof value === 'function') {\n      deepFreeze(value);\n    }\n  }\n\n  return Object.freeze(object);\n}\n\n/**\n * @private\n * Add key to model items and\n * load modeldata item into modelDataByStreamIdEventTypes for fast search\n */\nfunction loadModelDataByStreamIdEventTypes (model, map) {\n  for (const [key, item] of Object.entries(model)) {\n    // add key to item\n    item.key = key;\n    const eventTypes = [];\n    if (item.eventType) {\n      eventTypes.push(item.eventType);\n    } else {\n      eventTypes.push(...Object.keys(item.variations.eventType));\n    }\n    for (const eventType of eventTypes) {\n      const keyStreamIdEventType = item.streamId + ':' + eventType;\n      if (map[keyStreamIdEventType]) {\n        // should be tested with a faulty model\n        throw new Error(`Duplicate streamId + eventType \"${keyStreamIdEventType}\" for item ${JSON.stringify(item)}`);\n      }\n      map[keyStreamIdEventType] = item;\n    }\n  }\n}\n\n/**\n * @param {Array<stream>} streams\n * @param {Object<string, stream>} map - key value map\n */\nfunction loadModelStreamsById (streams, map) {\n  if (!streams) return;\n  for (const stream of streams) {\n    if (map[stream.id]) {\n      // should be tested with a faulty model\n      throw new Error(`Duplicate streamId \"${stream.id}\" for strean ${JSON.stringify(stream)}`);\n    }\n    map[stream.id] = stream;\n    loadModelStreamsById(stream.children, map);\n  }\n}\n","class HDSItemDef {\n  #data;\n  #key;\n\n  constructor (key, definitionData) {\n    this.#key = key;\n    this.#data = definitionData;\n  }\n\n  get eventTypes () {\n    if (this.#data.eventType) return [this.#data.eventType];\n    return Object.keys(this.#data.variations.eventType);\n  }\n\n  get key () {\n    return this.#key;\n  }\n\n  get data () {\n    return this.#data;\n  }\n}\n\nmodule.exports = HDSItemDef;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Export for webpack build\n */\nexport const HDSModel = require('./HDSModel');\n"],"names":["HDSItemDef","mixAuthorizationLevels","level1","level2","levels","sort","includes","Error","deepFreeze","object","propNames","Reflect","ownKeys","name","value","Object","freeze","loadModelStreamsById","streams","map","stream","id","JSON","stringify","children","module","exports","constructor","modelUrl","this","load","response","fetch","resultText","text","result","parse","model","key","item","entries","eventTypes","eventType","push","keys","variations","keyStreamIdEventType","streamId","loadModelDataByStreamIdEventTypes","items","itemDefForKey","throwErrorIfNotFound","defData","itemDefForEvent","event","candidates","streamIds","type","candidate","length","c","join","streamsGetNecessaryListForItemKeys","itemKeys","Map","itemKey","itemDef","streamParentIds","streamGetParentsIds","data","has","streamDataGetById","set","parentId","streamData","initialArray","unshift","authorizationForItemKeys","options","opts","defaultLevel","preRequest","includeDefaultName","assign","streamsRequested","pre","defaultName","level","auth","values","parents","parent","found","definitionData","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","HDSModel"],"sourceRoot":""}